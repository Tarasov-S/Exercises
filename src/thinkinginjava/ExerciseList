Thinking in Java: Exercises List


    ############################################
    #### Chapter 2: Everything Is an Object ####
    ############################################

        Exercise 1:   (2)
            Create a class containing an int and a char that are not initialized, and print their values to verify that
            Java performs default initialization.

        Exercise 2:   (1)
            Following the HelloDate.java example in this chapter, create a “hello, world” program that simply displays
            that statement. You need only a single method in your class (the “main” one that gets executed when
            the program starts). Remember to make it static and to include the argument list, even though you don’t use
            the argument list. Compile the program with javac and run it using java. If you are using a different
            development environment than the JDK, learn how to compile and run programs in that environment.

        Exercise 3:   (1)
            Find the code fragments involving ATypeName and turn them into a program that compiles and runs.

        Exercise 4:   (1)
            Turn the DataOnly code fragments into a program that compiles and runs.

        Exercise 5:   (1)
            Modify the previous exercise so that the values of the data in DataOnly are assigned to and printed in main( ).

        Exercise 6:   (2)
            Write a program that includes and calls the storage( ) method defined as a code fragment in this chapter.

        Exercise 7:   (1)
            Turn the Incrementable code fragments into a working program.

        Exercise 8:   (3)
            Write a program that demonstrates that, no matter how many objects you create of a particular class,
            there is only one instance of a particular static field in that class.

        Exercise 9:   (2)
            Write a program that demonstrates that autoboxing works for all the primitive types and their wrappers.

        Exercise 10:   (2)
            Write a program that prints three arguments taken from the command line. To do this, you’ll need to index
            into the command-line array of Strings.

        Exercise 11:   (1)
            Turn the AllTheColorsOfTheRainbow example into a program that compiles and runs.

        Exercise 12:   (2)
            Find the code for the second version of HelloDate.java, which is the simple comment documentation example.
            Execute Javadoc on the file and view the results with your Web browser.

        Exercise 13:   (1)
            Run Documentation1.java, Documentation2.java, and Documentation3.java through Javadoc. Verify the resulting
            documentation with your Web browser.

        Exercise 14:   (1)
            Add an HTML list of items to the documentation in the previous exercise.

        Exercise 15:   (1)
            Take the program in Exercise 2 and add comment documentation to it. Extract this comment documentation into
            an HTML file using Javadoc and view it with your Web browser.

        Exercise 16:   (1)
            In the Initialization & Cleanup chapter, locate the Overloading.java example and add Javadoc documentation.
            Extract this comment documentation into an HTML file using Javadoc and view it with your Web browser.


    ##############################
    #### Chapter 3: Operators ####
    ##############################

        Exercise 1:   (1)
            Write a program that uses the “short” and normal form of print statement.

        Exercise 2:   (1)
            Create a class containing a float and use it to demonstrate aliasing.

        Exercise 3:   (1)
            Create a class containing a float and use it to demonstrate aliasing during method calls.

        Exercise 4:   (2)
            Write a program that calculates velocity using a constant distance and a constant time.

        Exercise 5:   (2)
            Create a class called Dog containing two Strings: name and says. In main( ), create two dog objects with
            names “spot” (who says, “Ruff!”) and “scruffy” (who says, “Wurf!”). Then display their names and what they say.

        Exercise 6:   (3)
            Following Exercise 5, create a new Dog reference and assign it to spot’s object. Test for comparison
            using == and equals( ) for all references.

        Exercise 7:   (3)
            Write a program that simulates coin-flipping.

        Exercise 8:   (2)
            Show that hex and octal notations work with long values. Use Long.toBinaryString( ) to display the results.

        Exercise 9:   (1)
            Display the largest and smallest numbers for both float and double exponential notation.

        Exercise 10:   (3)
            Write a program with two constant values, one with alternating binary ones and zeroes, with a zero in
            the least-significant digit, and the second, also alternating, with a one in the least-significant digit
            (hint: It’s easiest to use hexadecimal constants for this). Take these two values and combine them in all
            possible ways using the bitwise operators, and display the results using Integer.toBinaryString( ).

        Exercise 11:   (3)
            Start with a number that has a binary one in the most significant position (hint: Use a hexadecimal constant).
            Using the signed right-shift operator, right shift it all the way through all of its binary positions, each
            time displaying the result using Integer.toBinaryString( ).

        Exercise 12:   (3)
            Start with a number that is all binary ones. Left shift it, then use the unsigned right-shift operator to
            right shift through all of its binary positions, each time displaying the result using Integer.toBinaryString( ).

        Exercise 13:   (1)
            Write a method that displays char values in binary form. Demonstrate it using several different characters.

        Exercise 14:   (3)
            Write a method that takes two String arguments and uses all the boolean comparisons to compare the two
            Strings and print the results. For the == and !=, also perform the equals( ) test. In main( ), call your
            method with some different String objects.


    ##########################################
    #### Chapter 4: Controlling Execution ####
    ##########################################

        Exercise 1:   (1)
            Write a program that prints values from 1 to 100.

        Exercise 2:   (2)
            Write a program that generates 25 random int values. For each value, use an if-else statement to classify
            it as greater than, less than, or equal to a second randomly generated value.

        Exercise 3:   (1)
            Modify Exercise 2 so that your code is surrounded by an “infinite” while loop. It will then run until
            you interrupt it from the keyboard (typically by pressing Control-C).

        Exercise 4:   (3)
            Write a program that uses two nested for loops and the modulus operator (%) to detect and print prime numbers
            (integral numbers that are not evenly divisible by any other numbers except for themselves and 1).

        Exercise 5:   (4)
            Repeat Exercise 10 from the previous chapter, using the ternary operator and a bitwise test to display
            the ones and zeroes, instead of Integer.toBinaryString( ).

        Exercise 6:   (2)
            Modify the two test( ) methods in the previous two programs so that they take two extra arguments, begin
            and end, and so that testval is tested to see if it is within the range between (and including) begin and end.

        Exercise 7:   (1)
            Modify Exercise 1 so that the program exits by using the break keyword at value 99. Try using return instead.

        Exercise 8:   (2)
            Create a switch statement that prints a message for each case, and put the switch inside a for loop that
            tries each case. Put a break after each case and test it, then remove the breaks and see what happens.

        Exercise 9:   (4)
            A Fibonacci sequence is the sequence of numbers 1, 1, 2, 3, 5, 8, 13, 21, 34, and so on, where each number
            (from the third on) is the sum of the previous two. Create a method that takes an integer as an argument
            and displays that many Fibonacci numbers starting from the beginning, e.g., If you run java Fibonacci 5
            (where Fibonacci is the name of the class) the output will be: 1, 1, 2, 3, 5.

        Exercise 10:   (5)
            A vampire number has an even number of digits and is formed by multiplying a pair of numbers containing
            half the number of digits of the result. The digits are taken from the original number in any order.
            Pairs of trailing zeroes are not allowed.
                Examples include:
                1260 = 21 * 60
                1827 = 21 * 87
                2187 = 27 * 81
            Write a program that finds all the 4-digit vampire numbers. (Suggested by Dan Forhan.)


    ########################################################
    #### Chapter 5: Chapter 5: Initialization & Cleanup ####
    ########################################################

        Exercise 1:   (1)
            Create a class containing an uninitialized String reference. Demonstrate that this reference
            is initialized by Java to null.

        Exercise 2:   (2)
            Create a class with a String field that is initialized at the point of definition, and another one that
            is initialized by the constructor. What is the difference between the two approaches?

        Exercise 3:   (1)
            Create a class with a default constructor (one that takes no arguments) that prints a message.
            Create an object of this class.

        Exercise 4:   (1)
            Add an overloaded constructor to the previous exercise that takes a String argument and prints
            it along with your message.

        Exercise 5:   (2)
            Create a class called Dog with an overloaded bark( ) method. This method should be overloaded based on various
            primitive data types, and print different types of barking, howling, etc., depending on which overloaded
            version is called. Write a main( ) that calls all the different versions.

        Exercise 6:   (1)
            Modify the previous exercise so that two of the overloaded methods have two arguments (of two different types),
            but in reversed order relative to each other. Verify that this works.

        Exercise 7:   (1)
            Create a class without a constructor, and then create an object of that class in main( ) to verify that
            the default constructor is automatically synthesized.

        Exercise 8:   (1)
            Create a class with two methods. Within the first method, call the second method twice:
            the first time without using this, and the second time using this—just to see it working;
            you should not use this form in practice.

        Exercise 9:   (1)
            Create a class with two (overloaded) constructors. Using this,
            call the second constructor inside the first one.

        Exercise 10:   (2)
            Create a class with a finalize( ) method that prints a message. In main( ), create an object of your class.
            Explain the behavior of your program.

        Exercise 11:   (4)
            Modify the previous exercise so that your finalize( ) will always be called.

        Exercise 12:   (4)
            Create a class called Tank that can be filled and emptied, and has a termination condition that
            it must be empty when the object is cleaned up. Write a finalize( ) that verifies this termination condition.
            In main( ), test the possible scenarios that can occur when your Tank is used.

        Exercise 13:   (1)
            Verify the statements in the previous paragraph.

        Exercise 14:   (1)
            Create a class with a static String field that is initialized at the point of definition, and another
            one that is initialized by the static block. Add a static method that prints both fields and demonstrates
            that they are both initialized before they are used.

        Exercise 15:   (1)
            Create a class with a String that is initialized using instance initialization.

        Exercise 16:   (1)
            Create an array of String objects and assign a String to each element. Print the array by using a for loop.

        Exercise 17:   (2)
            Create a class with a constructor that takes a String argument. During construction, print the argument.
            Create an array of object references to this class, but don’t actually create objects to assign into the array.
            When you run the program, notice whether the initialization messages from the constructor calls are printed.

        Exercise 18:   (1)
            Complete the previous exercise by creating objects to attach to the array of references.

        Exercise 19:   (2)
            Write a method that takes a vararg String array. Verify that you can pass either a comma-separated
            list of Strings or a String[] into this method.

        Exercise 20:   (1)
            Create a main( ) that uses varargs instead of the ordinary main( ) syntax. Print all the elements in
            the resulting args array. Test it with various numbers of command-line arguments.

        Exercise 21:   (1)
            Create an enum of the least-valuable six types of paper currency. Loop through the values( )
            and print each value and its ordinal( ).

        Exercise 22:   (2)
            Write a switch statement for the enum in the previous example. For each case,
            output a description of that particular currency.


    ###################################
    #### Chapter 6: Access Control ####
    ###################################

        Exercise 1:   (1)
            Create a class in a package. Create an instance of your class outside of that package.


        Exercise 2:   (1)
            Take the code fragments in this section and turn them into a program,
            and verify that collisions do in fact occur.


        Exercise 3:   (2)
            Create two packages: debug and debugoff, containing an identical class with a debug( ) method.
            The first version displays its String argument to the console, the second does nothing.
            Use a static import line to import the class into a test program,
            and demonstrate the conditional compilation effect.


        Exercise 4:   (2)
            Show that protected methods have package access but are not public.


        Exercise 5:   (2)
            Create a class with public, private, protected, and package-access fields and method members.
            Create an object of this class and see what kind of compiler messages you get
            when you try to access all the class members.
            Be aware that classes in the same directory are part of the “default” package.


        Exercise 6:   (1)
            Create a class with protected data. Create a second class in the same file
            with a method that manipulates the protected data in the first class.


        Exercise 7:   (1)
            Create the library according to the code fragments describing access and Widget.
            Create a Widget in a class that is not part of the access package.


        Exercise 8:   (4)
            Following the form of the example Lunch.java, create a class called ConnectionManager
            that manages a fixed array of Connection objects.
            The client programmer must not be able to explicitly create Connection objects,
            but can only get them via a static method in ConnectionManager.
            When the ConnectionManager runs out of objects, it returns a null reference. Test the classes in main( ).

        Exercise 9:   (2)
            Create the following file in the access/local directory (presumably in your CLASSPATH):


            ####################################
            #### Chapter 7: Reusing Classes ####
            ####################################

        Exercise 1:   (2)
            Create a simple class. Inside a second class, define a reference to an object of the first class.
            Use lazy initialization to instantiate this object.

        Exercise 2:   (2)
            Inherit a new class from class Detergent. Override scrub( ) and add a new method called sterilize( ).

        Exercise 3:   (2)
            Prove the previous sentence.

        Exercise 4:   (2)
            Prove that the base-class constructors are (a) always called and (b) called before derived-class constructors.

        Exercise 5:   (1)
            Create two classes, A and B, with default constructors (empty argument lists) that announce themselves.
            Inherit a new class called C from A, and create a member of class B inside C.
            Do not create a constructor for C. Create an object of class C and observe the results.

        Exercise 6:   (1)
            Using Chess.java, prove the statements in the previous paragraph.

        Exercise 7:   (1)
            Modify Exercise 5 so that A and B have constructors with arguments instead of default constructors.
            Write a constructor for C and perform all initialization within C’s constructor.

        Exercise 8:   (1)
            Create a base class with only a non-default constructor,
            and a derived class with both a default (no-arg) and non-default constructor.
            In the derived-class constructors, call the base-class constructor.

        Exercise 9:   (2)
            Create a class called Root that contains an instance of each of the classes (that you also create)
            named Component1, Component2, and Component3. Derive a class Stem from Root that also contains
            an instance of each “component.”
            All classes should have default constructors that print a message about that class.

        Exercise 10:   (1)
            Modify the previous exercise so that each class only has non-default constructors.

        Exercise 11:   (3)
            Modify Detergent.java so that it uses delegation.

        Exercise 12:   (3)
            Add a proper hierarchy of dispose( ) methods to all the classes in Exercise 9.

        Exercise 13:   (2)
            Create a class with a method that is overloaded three times. Inherit a new class,
            add a new overloading of the method, and show that all four methods are available in the derived class.

        Exercise 14:   (1)
            In Car.java add a service( ) method to Engine and call this method in main( ).

        Exercise 15:   (2)
            Create a class inside a package. Your class should contain a protected method.
            Outside of the package, try to call the protected method and explain the results.
            Now inherit from your class and call the protected method from inside a method of your derived class.

        Exercise 16:   (2)
            Create a class called Amphibian. From this, inherit a class called Frog.
            Put appropriate methods in the base class. In main( ),
            create a Frog and upcast it to Amphibian and demonstrate that all the methods still work.

        Exercise 17:   (1)
            Modify Exercise 16 so that Frog overrides the method definitions from the base class
            (provides new definitions using the same method signatures). Note what happens in main( ).

        Exercise 18:   (2)
            Create a class with a static final field and a final field and demonstrate the difference between the two.

        Exercise 19:   (2)
            Create a class with a blank final reference to an object.
            Perform the initialization of the blank final inside all constructors.
            Demonstrate the guarantee that the final must be initialized before use,
            and that it cannot be changed once initialized.

        Exercise 20:   (1)
            Show that @Override annotation solves the problem in this section.

        Exercise 21:   (1)
            Create a class with a final method. Inherit from that class and attempt to overwrite that method.

        Exercise 22:   (1)
            Create a final class and attempt to inherit from it.

        Exercise 23:   (2)
            Prove that class loading takes place only once. Prove that loading may be caused by either
            the creation of the first instance of that class or by the access of a static member.

        Exercise 24:   (2)
            In Beetle.java, inherit a specific type of beetle from class Beetle,
            following the same format as the existing classes. Trace and explain the output.


            #################################
            #### Chapter 8: Polymorphism ####
            #################################

        Exercise 1:   (2)
            Create a Cycle class, with subclasses Unicycle, Bicycle and Tricycle.
            Demonstrate that an instance of each type can be upcast to Cycle via a ride( ) method.

        Exercise 2:   (1)
            Add the @Override annotation to the shapes example.

        Exercise 3:   (1)
            Add a new method in the base class of Shapes.java that prints a message,
            but don’t override it in the derived classes. Explain what happens.
            Now override it in one of the derived classes but not the others, and see what happens.
            Finally, override it in all the derived classes.

        Exercise 4:   (2)
            Add a new type of Shape to Shapes.java and verify in main( )
            that polymorphism works for your new type as it does in the old types.

        Exercise 5:   (1)
            Starting from Exercise 1, add a wheels( ) method in Cycle, which returns the number of wheels.
            Modify ride( ) to call wheels( ) and verify that polymorphism works.

        Exercise 6:   (1)
            Change Music3.java so that what( ) becomes the root Object method toString( ).
            Try printing the Instrument objects using System.out.println( ) (without any casting).

        Exercise 7:   (2)
            Add a new type of Instrument to Music3.java and verify that polymorphism works for your new type.

        Exercise 8:   (2)
            Modify Music3.java so that it randomly creates Instrument objects the way Shapes.java does.

        Exercise 9:   (3)
            Create an inheritance hierarchy of Rodent: Mouse, Gerbil, Hamster,etc. In the base class,
            provide methods that are common to all Rodents, and override these in the derived classes to perform
            different behaviors depending on the specific type of Rodent. Create an array of Rodent,
            fill it with different specific types of Rodents, and call your base-class methods to see what happens.

        Exercise 10:   (3)
            Create a base class with two methods. In the first method, call the second method.
            Inherit a class and override the second method. Create an object of the derived class,
            upcast it to the base type, and call the first method. Explain what happens.

        Exercise 11:   (1)
            Add class Pickle to Sandwich.java.

        Exercise 12:   (3)
            Modify Exercise 9 so that it demonstrates the order of initialization of the base classes
            and derived classes. Now add member objects to both the base and derived classes and show the order
            in which their initialization occurs during construction.

        Exercise 13:   (3)
            Add a finalize( ) method to ReferenceCounting.java to verify the termination condition
            (see the Initialization & Cleanup chapter).

        Exercise 14:   (4)
            Modify Exercise 12 so that one of the member objects is a shared object with reference counting,
            and demonstrate that it works properly.

        Exercise 15:   (2)
            Add a RectangularGlyph to PolyConstructors.java and demonstrate the problem described in this section.

        Exercise 16:   (3)
            Following the example in Transmogrify.java, create a Starship class containing an AlertStatus reference
            that can indicate three different states. Include methods to change the states.

        Exercise 17:   (2)
            Using the Cycle hierarchy from Exercise 1, add a balance( ) method to Unicycle and Bicycle,
            but not to Tricycle. Create instances of all three types and upcast them to an array of Cycle.
            Try to call balance( ) on each element of the array and observe the results. Downcast and call balance( )
            and observe what happens.


            ###############################
            #### Chapter 9: Interfaces ####
            ###############################
